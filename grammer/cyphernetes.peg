{
    package cmd
}

Expression
    = Clause+

Clause
    = MatchClause / CreateClause / SetClause / DeleteClause / ReturnClause

MatchClause
    = "MATCH" ws NodePattern:n ws RelationshipPattern:r ws ReturnClause:rc {
        return &MatchClause{NodePattern: n.(*NodePattern), RelationshipPattern: r.(*RelationshipPattern), ReturnClause: rc.(*ReturnClause)}, nil
    }

CreateClause
    = "CREATE" ws NodePattern:n ws RelationshipPattern:r ws ReturnClause:rc {
        return &CreateClause{NodePattern: n.(*NodePattern), RelationshipPattern: r.(*RelationshipPattern), ReturnClause: rc.(*ReturnClause)}, nil
    }

SetClause
    = "SET" ws Identifier:i ws "=" ws PropertyValue:v ws ReturnClause:rc {
        return &SetClause{Identifier: i, PropertyValue: v, ReturnClause: rc.(*ReturnClause)}, nil
    }

DeleteClause
    = "DELETE" ws Identifier:i {
        return &DeleteClause{Identifier: i}, nil
    }

ReturnClause
    = "RETURN" ws ReturnItems:ris {
        return &ReturnClause{ReturnItems: ris.([]string)}, nil
    }

NodePattern
    = "(" ws Identifier:i ws ":" ws Label:l ws ")" {
        return &NodePattern{Identifier: i, Label: l}, nil
    }

RelationshipPattern
    = "-" ws "[" ws Identifier:i ws ":" ws Label:l ws "]" ws "->" {
        return &RelationshipPattern{Identifier: i, Label: l, Direction: "forward"}, nil
    }
    / "<-" ws "[" ws Identifier:i ws ":" ws Label:l ws "]" ws "-" {
        return &RelationshipPattern{Identifier: i, Label: l, Direction: "backward"}, nil
    }

ReturnItems
    = Identifier:i { return []string{i}, nil }

Identifier
    = [a-zA-Z_][a-zA-Z_0-9]*

Label
    = [a-zA-Z_][a-zA-Z_0-9]*

PropertyValue
    = StringLiteral / NumberLiteral / BooleanLiteral

StringLiteral
    = "\"" (!"\"" .)* "\"" { return string(c.text), nil }

NumberLiteral
    = [0-9]+ ("." [0-9]+)? { return string(c.text), nil }

BooleanLiteral
    = "true" / "false" { return string(c.text), nil }

ws
    = [ \t\n\r]*
