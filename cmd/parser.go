// parser/parser.go
package cmd

import (
	"fmt"
)

type Expression struct {
	Clauses []Clause
}

type Clause interface {
	isClause()
}

type MatchClause struct {
	NodePattern          *NodePattern
	ConnectedNodePattern *NodePattern
}

// type CreateClause struct {
// 	NodePattern         *NodePattern
// 	RelationshipPattern *RelationshipPattern
// }

// type SetClause struct {
// 	Identifier    string
// 	PropertyValue string
// }

type ReturnClause struct {
	JsonPaths []string
}

// type ReturnClause struct {
// 	ReturnItems []string
// }

type NodePattern struct {
	Name       string
	Kind       string
	Properties *Properties
}

// type RelationshipPattern struct {
// 	Identifier string
// 	Label      string
// 	Direction  string
// }

type Properties struct {
	PropertyList []*Property
}

type Property struct {
	Key string
	// Value is string int or bool
	Value interface{}
}

type JSONPathValueList struct {
	JSONPathValues []*JSONPathValue
}

type JSONPathValue struct {
	Value interface{}
}

// Implement isClause for all Clause types
func (m *MatchClause) isClause() {}

// func (c *CreateClause) isClause() {}
// func (s *SetClause) isClause()    {}
// func (d *DeleteClause) isClause() {}
func (r *ReturnClause) isClause() {}

var result *Expression

func ParseQuery(query string) (*Expression, error) {
	// Initialize the lexer with the query string
	lexer := NewLexer(query)

	// Call the parser function generated by goyacc
	// yyParse returns an int, with 0 indicating success
	if yyParse(lexer) != 0 {
		// Handle parsing error
		return nil, fmt.Errorf("parsing failed")
	}

	// Return the global result variable
	return result, nil
}
