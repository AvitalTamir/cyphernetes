![Cyphernetes Logo](./logo.png)

# Cyphernetes

Cyphernetes is a command-line interface (CLI) tool designed to manage Kubernetes resources using a query language inspired by Cypher, the query language of Neo4j. It provides a more intuitive way to interact with Kubernetes clusters, allowing users to express complex operations as graph-like queries.

## Why Cyphernetes?

Kubernetes management often involves dealing with complex and verbose command-line instructions. Cyphernetes simplifies this complexity by introducing a declarative query language that can express these instructions in a more readable and concise form. By leveraging a query language similar to Cypher, users can efficiently perform CRUD operations on Kubernetes resources, visualize resource connections, and manage their Kubernetes clusters with greater ease and flexibility.

## Development

Cyphernetes is written in Go and utilizes a parser generated by goyacc to interpret the custom query language.

### Prerequisites

- Go (1.16 or later)
- goyacc (for generating the parser)
- Make (for running make commands)

### Getting Started

To get started with development:

1. Clone the repository:
    ```bash
    git clone https://github.com/avitaltamir/cyphernetes.git
    ```

2. Navigate to the project directory:
    ```bash
    cd cyphernetes
    ```

### Building the Project

Use the Makefile commands to build the project:

- Test & Build:
    ```bash
    $ make
    ```
- To build the binary:
    ```bash
    make build
    ```

- To run tests:
    ```bash
    $ make test
    ```

- To generate the grammar parser:
    ```bash
    $ make gen-parser
    ```

- To clean up the build:
    ```bash
    $ make clean
    ```

### Contributing

Contributions are welcome! Please feel free to submit pull requests, open issues, and provide feedback.

## Project Roadmap

### Initial Project Setup

- [x] Initialize the project repository.
- [x] Set up version control with Git.
- [x] Create and document the project directory structure.
- [x] Choose a Go package management tool and initialize the package.
- [x] Set up a Go workspace with the necessary Go modules.

### Tooling and Framework

- [x] Set up a testing framework using Go's built-in testing package.
- [x] Configure a continuous integration service.
- [x] Establish linting and code formatting tools.
- [x] Implement logging and debug output mechanisms.

### Lexer and Parser Development

- [x] Create the basic lexer with support for initial tokens.
- [x] Develop a yacc file for the initial grammar rules.
- [x] Write unit tests for basic tokenization.
- [x] Implement a basic parser to handle `MATCH` queries.
- [x] Test and debug the lexer and parser with simple queries.

### Expanding Lexer and Parser

- [ ] Add support for additional tokens (e.g., braces, commas, relationship types).
- [ ] Extend grammar rules to cover node properties and relationships.
- [ ] Implement parsing logic for `CREATE`, `SET`, and `DELETE` keywords.
- [ ] Refine error handling for syntax and parsing errors.
- [ ] Optimize lexer and parser for performance.
- [ ] Continuously write tests for new grammar rules and features.

### Kubernetes Client Integration

- [ ] Evaluate and select a Go Kubernetes client library.
- [ ] Set up authentication and configuration for accessing a Kubernetes cluster.
- [ ] Implement a wrapper around the Kubernetes client to execute basic queries.
- [ ] Develop mapping logic to convert parsed queries into Kubernetes API calls.
- [ ] Test Kubernetes client integration with mock and real clusters.
- [ ] Add support for complex queries involving multiple Kubernetes resources.

### Interactive Shell Interface

- [ ] Design a CLI interface for inputting queries and displaying results.
- [ ] Implement CLI commands corresponding to query operations.
- [ ] Integrate the CLI with the parser and Kubernetes client.
- [ ] Test CLI with various input scenarios.

## Cypher-Like Query Language Parser Roadmap

The goal of this roadmap is to incrementally develop a parser that can handle a Cypher-like query language. The final version should support complex queries involving `MATCH`, `RETURN`, `CREATE`, `SET`, and `DELETE` statements.

### Phase 1: Basic MATCH Support

- [x] Support for basic `MATCH` queries (e.g., `MATCH (k:Kind)`).
- [x] Write unit tests for basic `MATCH` query parsing.

### Phase 2: RETURN Clause

- [ ] Implement parsing of the `RETURN` clause.
  - [ ] Update the lexer to recognize the `RETURN` keyword.
  - [ ] Extend the yacc grammar to include `RETURN` statement rules.
  - [ ] Write unit tests for queries with `RETURN` clauses.

### Phase 3: Relationships

- [ ] Support parsing of relationships in `MATCH` queries.
  - [ ] Update the lexer to recognize relationship pattern tokens (e.g., `-[]->`).
  - [ ] Extend the yacc grammar to handle relationship patterns.
  - [ ] Write unit tests for `MATCH` queries involving relationships.

### Phase 4: Node Properties

- [ ] Extend the parser to handle node properties.
  - [ ] Update the lexer to recognize curly braces and commas.
  - [ ] Update the yacc file to handle node properties syntax.
  - [ ] Write unit tests for `MATCH` queries with node properties.

### Phase 5: CREATE Statement

- [ ] Add support for `CREATE` statements.
  - [ ] Update the lexer to recognize the `CREATE` keyword.
  - [ ] Extend the yacc grammar to parse `CREATE` statements.
  - [ ] Write unit tests for `CREATE` statement parsing.

### Phase 6: SET Clause

- [ ] Implement parsing of the `SET` clause.
  - [ ] Update the lexer to recognize the `SET` keyword and property assignment syntax.
  - [ ] Extend the yacc grammar to include `SET` statement rules.
  - [ ] Write unit tests for queries with `SET` clauses.

### Phase 7: DELETE Statement

- [ ] Add support for `DELETE` statements.
  - [ ] Update the lexer to recognize the `DELETE` keyword.
  - [ ] Extend the yacc grammar to parse `DELETE` statements.
  - [ ] Write unit tests for `DELETE` statement parsing.

### Phase 8: Complex Query Parsing

- [ ] Combine all elements to support full query parsing.
  - [ ] Ensure the lexer and yacc grammar can handle complex queries with multiple clauses.
  - [ ] Write unit tests for parsing full queries including `MATCH`, `RETURN`, `CREATE`, `SET`, and `DELETE`.

## License

Cyphernetes is open-sourced under the MIT license. See the [LICENSE](LICENSE) file for details.

## Acknowledgments

- Thanks to the [Neo4j](https://neo4j.com/) community for the inspiration behind the query language.

## Authors

- Your Name - _Initial work_ - [Avital Tamir](https://github.com/avitaltamir)

See also the list of [contributors](https://github.com/yourusername/cyphernetes/contributors) who participated in this project.
